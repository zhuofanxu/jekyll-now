---
layout: post
title: PostgreSQL 事务隔离级别
category: 数据库
---

Read Commited 事务隔离级别下
`UPDATE`、`DELETE`、`SELECT FOR UPDATE` 和 `SELECT FOR SHARE` 命令在搜索目标行时的行为和 `SELECT` 一样： 它们将只找到在命令开始时已经被提交的行。 不过，在被找到时，这样的目标行可能已经被其它并发事务更新（或删除或锁住）。在这种情况下， 即将进行的更新将等待第一个更新事务提交或者回滚（如果它还在进行中）。 如果第一个更新事务回滚，那么它的作用将被忽略并且第二个事务可以继续更新最初发现的行。 如果第一个更新事务提交，若该行被第一个更新者删除，则第二个更新事务将忽略该行，否则第二个更新者将试图在`该行的已被更新的版本上`应用它的操作。`该命令的搜索条件（WHERE子句）`将被`重新计算`来看该行被更新的版本是否仍然符合搜索条件。如果符合，则第二个更新者使用该行的已更新版本继续其操作。在`SELECT FOR UPDATE` 和 `SELECT FOR SHARE` 的情况下，这意味着把该行的已更新版本锁住并返回给客户端。 

SELECT查询看到的是一个在查询开始运行的瞬间该数据库的一个快照。  
SELECT可以看见在它自身事务中之前执行的更新的效果，即使它们还没有被提交。  
还要注意的是，即使在同一个事务里两个相邻的SELECT命令可能看到不同的数据， 因为其它事务可能会在第一个SELECT开始和第二个SELECT开始之间提交。

postgresql 默认的事务隔离级别为 Read Commited 这对于大部分应用场景是足够的 因为这是数据库系统设计者们在事务并发性和数据一致性作出的权衡。  
不过，它不是对于所有情况都够用。做复杂查询和更新的应用可能需要比读已提交模式提供的更严格一致的数据库视图。

### 隐式加锁
Update、Delete 语句在执行的时候数据库系统会自动的在相应的行加上 `行排它锁` 直到包含该语句的事务提交后才释放。大多数关系型数据库系统基本上都会遵从这个准则的。

### 死锁
死锁：指两个（或多个）事务相互持有对方想要的锁。
PostgreSQL能够自动检测到死锁情况并且会通过中断其中一个事务从而允许其它事务完成来解决这个问题。被终端的具体事务很难预测。

事务A
```shell
begin;
UPDATE accounts SET balance = balance + 100.00 WHERE id = 2;
UPDATE accounts SET balance = balance - 100.00 WHERE id = 1;
end;
```
事务B
```shell
begin
UPDATE accounts SET balance = balance + 100.00 WHERE id = 1;
UPDATE accounts SET balance = balance - 100.00 WHERE id = 2;
end
```
A 与 B 并发执行 很可能发送死锁

### 防止死锁
防止死锁的最好方法通常是保证所有使用一个数据库的应用都以一致的顺序在多个对象上获得锁。在上面的例子里，如果两个事务以同样的顺序更新那些行，那么就不会发生死锁。 